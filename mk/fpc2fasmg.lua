local args = {...}
local input_file = args[1]
local output_file = args[2]

if not input_file or not output_file then
	print("Usage: lua fpc2lbf.lua <input.asm> <output.inc>")
	os.exit(1)
end

local fin = io.open(input_file, "r")
if fin == nil then
	print("Failed to open input file!")
	os.exit(1)
end

local fout = io.open(output_file, "w+")
if fout == nil then
	print("Failed to open output file!")
	os.exit(1)
end

local function strip_comment(line)
	local in_sq = false
	local in_dq = false

	for i = 1, #line do
		local c = line:sub(i, i)
		if c == "'" and not in_dq then
			in_sq = not in_sq
		elseif c == '"' and not in_sq then
			in_dq = not in_dq
		elseif not in_sq and not in_dq then
			if c == ';' or c == '#' then
				return line:sub(1, i - 1)
			end
		end
	end
	return line
end

local function trim(s)
	s = s:gsub("%s+$", "")
	s = s:gsub("^%s+", "")
	return s
end

local function clean(line)
	return trim(strip_comment(line))
end

local function is_data_section_name(sec_lower)
	if sec_lower:find("data", 1, true) then return true end
	if sec_lower:find("rodata", 1, true) then return true end
	if sec_lower:find("rdata", 1, true) then return true end
	if sec_lower:find("bss", 1, true) then return true end
	if sec_lower:find("const", 1, true) then return true end
	return false
end

local function is_code_section_name(sec_lower)
	if sec_lower:find("text", 1, true) then return true end
	if sec_lower:find("code", 1, true) then return true end
	return false
end

local current_seg = nil
local skipping_section = false

local function ensure_segment(seg)
	if skipping_section then return end
	if current_seg == seg then return end

	current_seg = seg
	if seg == "TEXT" then
		fout:write("segment 'TEXT', ST_CODE_RX\n")
	else
		fout:write("segment 'DATA', ST_DATA_RW\n")
	end
end

current_seg = "TEXT"
fout:write("segment 'TEXT', ST_CODE_RX\n")
fout:write("; generated by fpc2lbf.lua\n")

for line in fin:lines() do
	local s = clean(line)
	if s == "" then goto continue end

	local sl = s:lower()

	do
		local sec, attrs = s:match("^[Ss][Ee][Cc][Tt][Ii][Oo][Nn]%s+([^%s]+)%s*(.*)$")
		if not sec then
			sec, attrs = s:match("^[Ss][Ee][Gg][Mm][Ee][Nn][Tt]%s+([^%s]+)%s*(.*)$")
		end

		if sec then
			local sec_lower = sec:lower()

			if sec_lower:find("^%.debug") or sec_lower:find("^%.note") or sec_lower:find("^%.comment") then
				skipping_section = true
				fout:write("; [stripped section] " .. s .. "\n")
				goto continue
			end

			if is_data_section_name(sec_lower) then
				skipping_section = false
				ensure_segment("DATA")
				goto continue
			elseif is_code_section_name(sec_lower) then
				skipping_section = false
				ensure_segment("TEXT")
				goto continue
			else
				if not skipping_section then
					fout:write("; [mapped to " .. current_seg .. "] " .. s .. "\n")
				end
				goto continue
			end
		end
	end

	if skipping_section then
		goto continue
	end

	if s:sub(1, 1) == "%" then 
		fout:write("; [nasm-pp ignored] " .. s .. "\n")
		goto continue 
	end

	if sl:match("^cpu%s+") or sl:match("^default%s+") then 
		fout:write("; [ignored] " .. s .. "\n")
		goto continue 
	end

	if sl:match("^[Gg][Ll][Oo][Bb][Aa][Ll]%s+") then 
		fout:write("; [ignored global] " .. s .. "\n")
		goto continue 
	end

	if sl:match("^[Ee][Xx][Tt][Ee][Rr][Nn]%s+") or sl:match("^[Ee][Xx][Tt][Rr][Nn]%s+") then 
		fout:write("; [ignored extern] " .. s .. "\n")
		goto continue 
	end

	if sl:match("^org%s+") then 
		fout:write("; [org ignored] " .. s .. "\n")
		goto continue 
	end

	do
		local bits = s:match("^[Bb][Ii][Tt][Ss]%s+(%d+)")
		if bits then
			if bits == "16" then 
				fout:write("use16\n")
			elseif bits == "32" then 
				fout:write("use32\n") 
			elseif bits == "64" then
				fout:write("; [invalid bits] " .. s .. "\n")
			else
				fout:write("; [unknown bits] " .. s .. "\n")
			end
			goto continue
		end
	end

	do
		local align_val = s:match("^[Aa][Ll][Ii][Gg][Nn]%s+(%d+)")
		if align_val then
			fout:write("align " .. align_val .. "\n")
			goto continue
		end
	end

	do
		local dataish =
			sl:match("^db%s+") or sl:match("^dw%s+") or sl:match("^dd%s+") or sl:match("^dq%s+") or
			sl:match("^dt%s+") or sl:match("^do%s+") or sl:match("^dy%s+") or sl:match("^dz%s+") or
			sl:match("^resb%s+") or sl:match("^resw%s+") or sl:match("^resd%s+") or sl:match("^resq%s+") or
			sl:match("^times%s+[%w_]+%s+db%s+") or sl:match("^times%s+[%w_]+%s+dw%s+") or sl:match("^times%s+[%w_]+%s+dd%s+")

		local is_label_only = s:match("^([%a_%.%@%$%?][%w_%.%@%$%?]*):%s*$") ~= nil

		if dataish and not is_label_only then
			ensure_segment("DATA")
		end
	end

	do
		local expr = s:match("^[Rr][Ee][Ss][Bb]%s+(.+)$")
		if expr then ensure_segment("DATA"); fout:write("rb " .. expr .. "\n"); goto continue end
		expr = s:match("^[Rr][Ee][Ss][Ww]%s+(.+)$")
		if expr then ensure_segment("DATA"); fout:write("rw " .. expr .. "\n"); goto continue end
		expr = s:match("^[Rr][Ee][Ss][Dd]%s+(.+)$")
		if expr then ensure_segment("DATA"); fout:write("rd " .. expr .. "\n"); goto continue end
		expr = s:match("^[Rr][Ee][Ss][Qq]%s+(.+)$")
		if expr then ensure_segment("DATA"); fout:write("rq " .. expr .. "\n"); goto continue end
	end

	do
		local count, stmt = s:match("^[Tt][Ii][Mm][Ee][Ss]%s+([^%s]+)%s+(.+)$")
		if count and stmt then
			local stmt_l = stmt:lower()

			if stmt_l:match("^db%s+") or stmt_l:match("^dd%s+") or stmt_l:match("^resb%s+") then
				ensure_segment("DATA")
			end
			fout:write("repeat " .. count .. "\n")
			fout:write("\t" .. stmt .. "\n")
			fout:write("end repeat\n")
			goto continue
		end
	end

	do
		if current_seg == "DATA" then
			local looks_like_code =
				sl:match("^[%a_%.%@%$%?][%w_%.%@%$%?]*:%s*[%a]+") or
				sl:match("^(mov|lea|call|jmp|je|jne|jg|jge|jl|jle|ja|jb|jc|jnc|push|pop|add|sub|xor|or|and|cmp|test|ret|retn|leave|enter|int|nop|cld|std|cli|sti|rep|repe|repne|imul|mul|idiv|div|shl|shr|sar|rol|ror|xchg|inc|dec|sbb|adc|neg|not|seta|setb|sete|setne|setz|setnz|loop|loope|loopne)%f[%s]")

			if looks_like_code then
				ensure_segment("TEXT")
			end
		end
	end

	fout:write(s .. "\n")

	::continue::
end

fin:close()
fout:close()
